#+STARTUP: showeverything
#+TITLE: A Linked List in an Array
#+SUBTITLE: CIS 310 Operating Systems
#+DATE: Fall 2021
#+AUTHOR: Brian C. Ladd
#+EMAIL: laddbc@potsdam.edu
#+OPTIONS: toc:nil H:1 num:0

* Prior Knowledge
Before this assignment, a student should be able to
- Write a C++ class
- Compile and debug C++ code
- Read C++ code that has comments

* Learning Outcomes
- Write a class that extends (not a keyword in C++) another class.
- Work with a string implemented as a linked list, and be able to translate a word into Pig Latin.
- Provide a ~README~ file that
  - Explains the problem being solved
  - Documents how to compile and run the program
  - Documents how to test the program is correct
    - Explain what input -> output would indicate that the program works.
    - Explain how that mapping was tested.
    - Explain any known /edge conditions/, what the correct behavior is, and how that was tested.
    - How to use /provided test data/ and /expected output/ to run the validation tests and confirm correctness.

* Introduction
Starting with an /abstract class/ (you can read that as /interface/ in the Java sense), you will implement the memory subsystem for a simple linked list program. The program will insert and remove elements from a linked list of strings using your memory module.

Start with the template for the code on Gitea.

* User Interface
See the provided ~README.org~ for instruction. This is a command-loop program that loops, reading one line at a time, and using the first letter of the line as a command and interpreting the remaining parts of the line as parameters when necessary.

Note that this program is *provided*.

* The Assignment
1. You must implement a class that implements all of the abstract member functions in ~src/memory/AbstractMemoryPool.h~
   - All member functions are virtual and abstract.
     - An abstract member function is indicated with = 0 at the end of the declaration.
   - Look at how to /inherit/ from a class and write a header file (probably in ~src/memory~) for your class. You can add any public or private members or functions to your class.
     - Provided code interacts with a memory pool through a pointer at the abstract class. That means that it does not call any functions other than those in the base class.
     - Implement /stub/ functions that do as little as possible (return false or null or do nothing) and get that to compile. Then uncomment the setting of the ~ListString~ pool in ~src/main/igpayAtinlay.cpp~.
   - The ~ListString~ class is *almost* complete (see below): you can use it to test your memory pool.
     - Your pool has an array of the ~Node~ type. No class outside of your pool can see that type. All other classes can see ~NodePtr~ which is actually an int. The constant ~nullNodePtr~ serves the purpose of ~nullptr~ for regular C++ pointers.
     - You are to keep track of free nodes on a free list. It is possible that getting that and the method to print the free list might be a good place to start (you can see what your free list looks like).
     - You need to be able to dump the nodes in a string.
     - You need to be able to allocate and deallocate nodes in any order.
2. You must implement the ~igpayAtinlay~ member function in the ~ListString~ class.
   - English vowels are (any case) {a,e,i,o,u}
   - If the first character of a "word" is not alphabetic (look for predicate functions to make this easy to check), leave the string unchanged.
   - Given a string starting with a letter: find the first vowel. Take off the prefix *before* the vowel (it might be empty) and move it to the end of the string (the remaining string, too, might be empty).
   - If there were no consonants rotated, append "way" to the end of the string; if consonants were rotated, then append "ay":
     - "1116" -> "1116"
     - "pig" -> "igp" -> "igpay"
     - "Latin" -> "atinL" -> "atinLay"
     - "umbrella" -> "umbrella" -> "umbrellaway"
   - The member function for doing this is a stub. You will modify ~src/list/ListString.cpp~ and can test it through the commands in the driver.

* Notes
** ~static~ functions/members are /class-wide/
This is just like the use of ~static~ in Java.

* Design Requirements
** Probably no need to add modules.
** You are implementing a new class.
This means adding a ~.h~ and a ~.cpp~ file. Since you're implementing a memory pool, ~src/memory~ seems a good place to put your code.
** Inside your pool, you have an *array* indexed by integers
You are not to change the type of ~NodePtr~. Given a ~NodePtr~, ~n~, you would refer to the corresponding node as ~A[n]~ (assuming ~A~ is the name of the array of ~Node~ objects in your pool class).

* Deliverables
All of your code, using the standard make system for CIS 310, test artifacts, and documentation is to be put into a git repository and pushed to a repository on cs-devel.potsdam.edu (Gitea).

** Repository Name
The name of the repository (on the server) must be like this

laddbc-CIS310-202109-pSortAnArray
|      |      |      |- Name of the assignment
|      |      |- Semester as year (2021) and 01/09 for Spring/Fall
|      |- Department and number of course
|- Campus-wide Login Name

* Documentation
  *Note that these requirements, repeated or not, apply to /all/ programming assignments in CIS 310.*
** Do not forget the =README.org= or =README.txt= file
*** The =README= document goes in the root directory of the project (where the ~Makefile~ lives)
*** It is in plain text or Org mode formatting
*** It must contain (at least) the following:
- Identification Block :: Much as described in the next section, the =README= must identify the programmer (with e-mail address) and the problem being solved. No ID block is the same as no =README=.
- Problem Restatement :: Restate the problem being solved to make the project self-contained. Restating the problem is also good practice to check that you understand what you are supposed to do.
- Testing Criteria :: You know by now that "it must be right, it compiles" is a silly statement. So, how do you know that you are done? You must document exactly how you tested your program with
  - Test Input :: Files or descriptions of what to give as input
  - Test Execution :: Commandlines and answers to prompts to execute your program with each set of test data.
  - Expected Output :: How to find the output and what the output is supposed to be. This should refer back to the input data and the assignment to establish that the expected output matches the problem being solved.
  - Compiling and Exectuitg Instructions :: Give clear /commandline specifications/ for compiling and running your program. What folder should the user be in to run the commands? What tool(s) does the process require? What do the commandline arguments /mean/?
*** The =README= must accompany every program you turn in.
