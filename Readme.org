#+STARTUP: showall
#+TITLE: Implementing a Memory Pool.
#+SUBTITLE: CIS 310: Operating Systems
#+AUTHOR: Brian C. Ladd
#+DATE: Fall 2021

* Introduction
What if strings were linked lists of characters? The included ~ListString~ class implements them in this way. The only odd thing is that rather than use ~new~/~delete~, the class uses a static ~AbstractMemoryPool~ (see ~src/memory/abstractMemoryPool.h~) to get memory and dereference it.

The driver, ~src/main/igpayAtinlay.cpp~ implements several commands. You should be able to compile it once you have defined empty methods for your memory pool. The line calling ~ListString::setPool~ will need to be uncommented to install your pool as the actual memory pool.

* User Interface
The commands are all single letters. There is an array of list string objects that are referred to by index when a command needs to refer to a string. When a value for a string is needed, it is a single word (sequence of non-whitespace characters).

The "a" (add) command takes a word and adds a new string with that word, if possible. The input, to add the string "Starcastle", would be

#+BEGIN_SRC bash
Action: (adfinpqst): a Starcastle
#+END_SRC

If string 7 is in use, setting (resetting) its value to "ShellAndTheCrush" would use the command:

#+BEGIN_SRC bash
Action: (adfinpqst): s 7 ShellAndTheCrush
#+END_SRC

The commands are:
- a <str> :: add <str> to an open string location, if there is one.
- d <ndx> :: delete the string at location <ndx>, if there is one.
- f :: memory pool to print its free list node numbers in order
- i <ndx> :: translate the string in <ndx> to Pig Latin. *NOT IMPLEMENTED* - part of your assignment.
- n <ndx> :: memory pool to print the nodes that make up this string with character, and the next node number.
- p :: print the string array with indices in use and contents.
- q :: quit
- s <ndx> <str> :: set the value of an in-use string to <str>.
- t :: toggle memory pool tracing of ~newNode~ and ~deleteNode~ calls.
- ? :: Display help message (also displayed after any unknown command).

Commands are read by the line so all parameters must appear on the same line and only one command can appear per line. There is no error checking on extra parameters.

* Building the project executables
This section assumes you are in the root directory of the project (the same directory with the ~Makefile~).

** Build the executables
#+BEGIN_SRC shell
$ make
#+END_SRC

All directories listed in the make include file in ~src/~ are "made" (checked if generated files are out of date or non-existent and generated if necessary). The make system picks up ~.cpp~ and ~.s~ files in the listed folders. It links executables in the ~build/~ directory, named for the source files in the various executable folders.

** To Clean --- delete all generated files
The next build will have to compile /all/ of the files rather than just the ones that have changed. This is helpful if different, dependent packages get out of sync.

#+BEGIN_SRC shell
$ make clean
#+END_SRC

Primarily deletes (recursively) the ~build/~ folder.

** To Test
The test executable for this project is named ~stringEntryTest~. After a successful build, the file will be in the ~build/~ folder. The output is generated by Catch2 and should show all tests passing.

#+BEGIN_SRC shell
$ build/stringEntryTest
=================================================================
All tests passed (69 assertions in 6 test cases)
#+END_SRC

Note that the number of assertions and test cases may be different as this was captured before the test suite was ready for student consumption.

** To Run
Each project, when built, shows the name of the executable as the parameter of the -o commandline argument. So, in  the commandline make used to build an executable named ~readBy~,
#+BEGIN_SRC shell
g++ -std=c++17 -Wall -Werror -g  -o build/readBy ...
#+END_SRC

the executable is build in ~./build/readBy~. The executable is named automatically for the ~.cpp~ file containing the ~main~ function; the source file containing the =main= function is in ~src/main/~ which is in the ~EXEC_SRC~ variable.

To run the program, type the path of the executable at the commandline
#+BEGIN_SRC shell
build/readBy
#+END_SRC

If it takes commandline parameters, they come after the executable
